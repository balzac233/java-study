## 锁

---

### 1. 锁的种类

- 按照**「锁的粒度」**分为：**表级锁、行级锁**

- 按照**「类型」**分为：**共享锁、排他锁**

- 按照**「思想」**分为：**乐观锁、悲观锁**

  

### 2.表级锁与行级锁

**「表级锁」**是粒度最大的锁，开销小，加锁快，不会出现死锁，但是由于粒度太大，造成锁的冲突几率大，并发性能低。MyISAM 和 InnoDB 存储引擎都支持表级锁。

**「行级锁」**是粒度最小的锁机制，开销大，加锁慢，并且会出现死锁，但是行锁的锁冲突的几率低，并发性能高。



### 3. MyISAM 和 InnoDB 存储引擎使用的锁：

- MyISAM 采用**表锁(table-level locking)**。

- InnoDB 支持**行级锁(row-level locking)和表级锁，默认为行级锁**

  

### 4.MYISAM存储引擎

#### 4.1 表共享读锁和表独占写锁

MyISAM中默认支持的表级锁有两种：**「表共享读锁（read lock）」**和**「表独占写锁（write lock）」**。表级锁在MyISAM和InnoDB的存储引擎中都支持，但是InnoDB默认支持的是行锁。

Mysql中可以通过以下sql来显示的在事务中显式的进行加锁和解锁操作：

```mysql
# 显式地添加表级读锁
LOCK TABLE 表名 READ
# 显示地添加表级写锁
LOCK TABLE 表名 WRITE
# 显式地解锁（当一个事务commit的时候也会自动解锁）
unlock tables;
```

在执行select语句的时候MySQL底层会隐式地加读锁，执行增、删、改的操作时就会隐式地加写锁。

**总结：**

**「当一个线程获取到表级读锁后，该线程只能读取数据不能修改数据，其它线程也只能加读锁，不能加写锁」**

**「当一个线程获取到表级写锁后，只能由该线程对表进行读写操作，别的线程必须等待该线程释放锁以后才能操作」**



#### 4.2 当MyISAM存储引擎发生锁竞争时，是如何处理的？

*读者写者问题--写者优先原则*

1. MyISAM存储引擎中，**「假如同时一个读请求，一个写请求过来的话，它会优先处理写请求」**，因为MyISAM存储引擎中认为写请求比都请求重要。
2. **「假如大量的读写请求过来，就会导致读请求长时间的等待，或者"线程饿死"，因此MyISAM不适合运用于大量读写操作的场景」**，这样会导致长时间读取不到用户数据，用户体验感极差。当然可以通过设置low-priority-updates参数，设置请求链接的优先级，使得Mysql优先处理读请求。



### 5. InnoDB存储引擎

#### 5.1 InnoDB的表级锁：

MyISAM中默认支持的表级锁有两种：**「表共享读锁（read lock）」**和**「表独占写锁（write lock）」**。表级锁在MyISAM和InnoDB的存储引擎中都支持，但是InnoDB默认支持的是行锁。



InnoDB有两种内部使用的意向锁（Intention Locks），这两种意向锁都是**表级锁**：

- **「意向共享锁（IS）」**：事务打算给数据行加**「行共享锁（S）」**，事务在给一个数据行加共享锁前必须先取得该表的 **「IS 锁」**。与**「表共享读锁（read lock）」**兼容，与**「表独占写锁（write lock）」**互斥。

- **「意向排他锁（IX）」**：事务打算给数据行加**「行排他锁（X）」**，事务在给一个数据行加排他锁前必须先取得该表的 **「IX 锁」**。与**「表共享读锁（read lock）」**及**「表独占写锁（write lock）」**都互斥，意向锁之间不会互斥。

`意向锁是有数据引擎自己维护的，用户无法手动操作意向锁`，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。

**意向锁作用**：如果另一个事务试图在该**==表级别==**上应用**「表共享读锁（read lock）」**或**「表独占写锁（write lock）」**，则受到由第一个事务控制的表级别意向锁的阻塞，第二个事务在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。*（一个事务在试图对表加表级锁的时候，必须保证：a.当前没有其他事务持有该表的排他锁。b.当前没有其他事务持有该表中任意一行的排他锁 。）*。一旦事务提交了，意向共享锁、意向排他锁都会自动释放。 

==**意向锁之间是互相兼容的，意向锁不会与行级的共享 / 排他锁互斥！！！**==

|            |  IS  |  IX  | 表共享读锁 | 表独占写锁 |
| :--------: | :--: | :--: | :--------: | :--------: |
|     IS     | 兼容 | 兼容 |    兼容    |    互斥    |
|     IX     | 兼容 | 兼容 |    互斥    |    互斥    |
| 表共享读锁 | 兼容 | 互斥 |    兼容    |    互斥    |
| 表独占写锁 | 互斥 | 互斥 |    互斥    |    互斥    |

 

#### 5.2 InnoDB的行级锁：

==InnoDB的数据时基于索引组织的，行级锁是通过对索引上的索引项加锁来实现的，而不是对记录家的锁。==

##### 5.2.1行级锁的三种算法：

- **「记录锁（Record lock）」**：锁定单个行记录的锁，防止其他事务对此行进行 update 和 delete。在
  Read Committed、Repeatable Read 隔离级别下都支持

  1. 针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为记录锁。
  2. ==InnoDB的记录锁是针对于**索引**加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁。==  

  ![image-20220505021156017](https://raw.githubusercontent.com/ayifuture0920/java-study/master/pictures/image-20220505021156017.png)

- **「间隙锁（Gap lock）」**：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在 Repeatable Read 隔离级别下都支持

  ![image-20220505021227863](https://raw.githubusercontent.com/ayifuture0920/java-study/master/pictures/image-20220505021227863.png)

- **「临键锁（Next-Key Lock）」**：记录锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。
  在 Repeatable Read 隔离级别下支持 

![image-20220505021319450](E:\Interest\pictures\image-20220505021319450.png)

##### 5.2.2行级锁的两种类型：

- **「共享锁（S）」**：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁，即S之间是兼容的，S与X是互斥的。

  ```mysql
  select ... lock in share mod; #添加S锁
  ```

- **「排他锁（X）」**：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。

  ```mysql
  insert/ update/ delete/ select ... for update; #添加X锁
  ```

|      |  S   |  X   |
| :--: | :--: | :--: |
|  S   | 兼容 | 互斥 |
|  X   | 互斥 | 互斥 |

---

***参考：***

*https://juejin.cn/post/6844903666332368909#heading-6*

*https://juejin.cn/post/6844904197444354062#heading-10*

*https://cloud.tencent.com/developer/article/1822612*
